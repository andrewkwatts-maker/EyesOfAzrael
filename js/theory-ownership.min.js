class TheoryOwnership{constructor(){this.init()}init(){window.addEventListener("userLogin",()=>this.refreshOwnershipUI()),window.addEventListener("userLogout",()=>this.refreshOwnershipUI())}checkOwnership(e,r=null){if(!window.userAuth||!window.userAuth.isLoggedIn())return!1;const t=window.userAuth.getCurrentUser(),n=r||t.username,o=window.userTheories?.getTheory(e);return!!o&&(o.authorId===n||o.author===n)}canEdit(e){return!(!window.userAuth||!window.userAuth.isLoggedIn())&&this.checkOwnership(e)}canDelete(e){return!(!window.userAuth||!window.userAuth.isLoggedIn())&&this.checkOwnership(e)}getTheoryAuthor(e){const r=window.userTheories?.getTheory(e);return r?{id:r.authorId||r.author,username:r.author,avatar:r.authorAvatar}:null}async verifyOwnership(e,r="edit"){return window.userAuth&&window.userAuth.isLoggedIn()?await(window.userTheories?.getTheory(e))?this.checkOwnership(e)?{authorized:!0}:{authorized:!1,error:`You can only ${r} your own theories`}:{authorized:!1,error:"Theory not found"}:{authorized:!1,error:`You must be logged in to ${r} theories`}}renderOwnershipActions(e,r){if(!this.canEdit(e)&&!this.canDelete(e))return;const t=`\n            <div class="ownership-actions" style="display: flex; gap: 1rem; margin-top: 1rem;">\n                ${this.canEdit(e)?`\n                    <button class="btn btn-edit" onclick="theoryOwnership.handleEdit('${e}')">\n                        Edit Theory\n                    </button>\n                `:""}\n                ${this.canDelete(e)?`\n                    <button class="btn btn-delete" onclick="theoryOwnership.handleDelete('${e}')">\n                        Delete Theory\n                    </button>\n                `:""}\n            </div>\n        `,n=document.createElement("div");n.innerHTML=t,r.appendChild(n.firstElementChild)}async handleEdit(e){const r=await this.verifyOwnership(e,"edit");r.authorized?window.location.href=`edit.html?id=${e}`:this.showError(r.error)}async handleDelete(e){const r=await this.verifyOwnership(e,"delete");r.authorized?window.deleteConfirmationModal?window.deleteConfirmationModal.show(e):confirm("Are you sure you want to delete this theory? This cannot be undone.")&&await this.executeDelete(e):this.showError(r.error)}async executeDelete(e){const r=await(window.userTheories?.deleteTheory(e));r&&r.success?(this.showSuccess("Theory deleted successfully. Redirecting..."),setTimeout(()=>{window.location.href="browse.html"},1500)):this.showError(r?.error||"Failed to delete theory")}refreshOwnershipUI(){window.dispatchEvent(new CustomEvent("ownershipChanged"))}showError(e){window.showNotification?window.showNotification(e,"error"):alert(e)}showSuccess(e){window.showNotification?window.showNotification(e,"success"):alert(e)}checkMultipleOwnership(e){const r=new Map;return e.forEach(e=>{r.set(e,this.checkOwnership(e))}),r}getCurrentUserTheories(){if(!window.userAuth||!window.userAuth.isLoggedIn())return[];const e=window.userAuth.getCurrentUser();return window.userTheories?.getUserTheories(e.username)||[]}}window.theoryOwnership=new TheoryOwnership,"undefined"!=typeof module&&module.exports&&(module.exports=TheoryOwnership);