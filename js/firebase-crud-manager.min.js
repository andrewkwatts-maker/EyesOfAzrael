class FirebaseCRUDManager{constructor(e,t){this.db=e,this.auth=t,this.validator=new EntityValidator,this.permissionManager=new PermissionManager(t)}async create(e,t){try{const r=this.auth.currentUser;if(!r)throw new Error("User must be authenticated to create entities");const i=this.validator.validate(t,e);if(!i.valid)throw new Error(`Validation failed: ${i.errors.join(", ")}`);const s={...t,createdBy:r.uid,createdByEmail:r.email,createdByName:r.displayName||r.email,createdAt:firebase.firestore.FieldValue.serverTimestamp(),updatedAt:firebase.firestore.FieldValue.serverTimestamp(),version:1,status:"active"},a=await this.db.collection(e).add(s);return window.AnalyticsManager&&window.AnalyticsManager.trackContributionAction("create",e,a.id),{success:!0,id:a.id,data:s}}catch(e){return{success:!1,error:e.message}}}async read(e,t){try{const r=this.db.collection(e).doc(t),i=await r.get();if(!i.exists)throw new Error("Entity not found");return{success:!0,data:{id:i.id,...i.data()}}}catch(e){return{success:!1,error:e.message}}}async readMany(e,t={}){try{let r=this.db.collection(e);if(t.where&&t.where.forEach(([e,t,i])=>{r=r.where(e,t,i)}),t.orderBy){const[e,i="asc"]=t.orderBy;r=r.orderBy(e,i)}t.limit&&(r=r.limit(t.limit)),t.offset&&(r=r.offset(t.offset));const i=await r.get(),s=i.docs.map(e=>({id:e.id,...e.data()}));return{success:!0,data:s,count:s.length,total:i.size}}catch(e){return{success:!1,error:e.message}}}async update(e,t,r){try{const i=this.auth.currentUser;if(!i)throw new Error("User must be authenticated to update entities");if(!await this.permissionManager.canEdit(e,t,i.uid))throw new Error("You do not have permission to edit this entity");const s=this.validator.validateUpdate(r,e);if(!s.valid)throw new Error(`Validation failed: ${s.errors.join(", ")}`);const a={...r,updatedAt:firebase.firestore.FieldValue.serverTimestamp(),updatedBy:i.uid,updatedByEmail:i.email,version:firebase.firestore.FieldValue.increment(1)};return await this.db.collection(e).doc(t).update(a),window.AnalyticsManager&&window.AnalyticsManager.trackContributionAction("edit",e,t),{success:!0}}catch(e){return{success:!1,error:e.message}}}async delete(e,t,r=!1){try{const i=this.auth.currentUser;if(!i)throw new Error("User must be authenticated to delete entities");if(!await this.permissionManager.canDelete(e,t,i.uid))throw new Error("You do not have permission to delete this entity");const s=this.db.collection(e).doc(t);return r?await s.delete():await s.update({status:"deleted",deletedAt:firebase.firestore.FieldValue.serverTimestamp(),deletedBy:i.uid,deletedByEmail:i.email}),window.AnalyticsManager&&window.AnalyticsManager.trackContributionAction("delete",e,t),{success:!0}}catch(e){return{success:!1,error:e.message}}}async restore(e,t){try{const r=this.auth.currentUser;if(!r)throw new Error("User must be authenticated to restore entities");if(!await this.permissionManager.canEdit(e,t,r.uid))throw new Error("You do not have permission to restore this entity");return await this.db.collection(e).doc(t).update({status:"active",restoredAt:firebase.firestore.FieldValue.serverTimestamp(),restoredBy:r.uid,deletedAt:firebase.firestore.FieldValue.delete(),deletedBy:firebase.firestore.FieldValue.delete(),deletedByEmail:firebase.firestore.FieldValue.delete()}),{success:!0}}catch(e){return{success:!1,error:e.message}}}async getUserEntities(e,t={}){const r=this.auth.currentUser;return r?this.readMany(e,{...t,where:[...t.where||[],["createdBy","==",r.uid]]}):{success:!1,error:"User not authenticated"}}}class EntityValidator{constructor(){this.schemas={deities:{required:["name","mythology","type"],optional:["description","domains","symbols","family","attributes"]},creatures:{required:["name","mythology","type"],optional:["description","habitat","abilities"]},heroes:{required:["name","mythology","type"],optional:["description","quests","weapons"]},items:{required:["name","mythology","type"],optional:["description","powers","owner"]},places:{required:["name","mythology","type"],optional:["description","significance","inhabitants"]},texts:{required:["name","mythology","type"],optional:["description","author","date","content"]},rituals:{required:["name","mythology","type"],optional:["description","purpose","steps","offerings"]},herbs:{required:["name","mythology","type"],optional:["description","uses","preparation"]},symbols:{required:["name","mythology","type"],optional:["description","meaning","usage"]},concepts:{required:["name","mythology","type"],optional:["description","significance"]}}}validate(e,t){const r=[],i=this.schemas[t];return i?(i.required.forEach(t=>{e[t]||r.push(`Missing required field: ${t}`)}),e.name&&"string"!=typeof e.name&&r.push("Name must be a string"),e.mythology&&"string"!=typeof e.mythology&&r.push("Mythology must be a string"),e.type&&"string"!=typeof e.type&&r.push("Type must be a string"),["domains","symbols","abilities","quests","weapons","powers"].forEach(t=>{e[t]&&!Array.isArray(e[t])&&r.push(`${t} must be an array`)}),{valid:0===r.length,errors:r}):(r.push(`Unknown collection: ${t}`),{valid:!1,errors:r})}validateUpdate(e,t){const r=[];return["id","createdBy","createdAt","createdByEmail","createdByName"].forEach(t=>{e.hasOwnProperty(t)&&r.push(`Cannot update immutable field: ${t}`)}),e.name&&"string"!=typeof e.name&&r.push("Name must be a string"),e.mythology&&"string"!=typeof e.mythology&&r.push("Mythology must be a string"),["domains","symbols","abilities","quests","weapons","powers"].forEach(t=>{e[t]&&!Array.isArray(e[t])&&r.push(`${t} must be an array`)}),{valid:0===r.length,errors:r}}}class PermissionManager{constructor(e){this.auth=e,this.adminEmails=["andrewkwatts@gmail.com"]}async isAdmin(e){const t=this.auth.currentUser;return!(!t||t.uid!==e)&&this.adminEmails.includes(t.email)}async canEdit(e,t,r){if(await this.isAdmin(r))return!0;const i=firebase.firestore(),s=await i.collection(e).doc(t).get();return!!s.exists&&s.data().createdBy===r}async canDelete(e,t,r){return this.canEdit(e,t,r)}async canRead(e,t,r){const i=firebase.firestore(),s=await i.collection(e).doc(t).get();if(!s.exists)return!1;const a=s.data();return"active"===a.status||"deleted"===a.status&&(a.createdBy===r||await this.isAdmin(r))}}"undefined"!=typeof module&&module.exports&&(module.exports={FirebaseCRUDManager:FirebaseCRUDManager,EntityValidator:EntityValidator,PermissionManager:PermissionManager});