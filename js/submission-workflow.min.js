import{ENTITY_COLLECTIONS}from"./constants/entity-types.js";class SubmissionWorkflow{constructor(){this.db=null,this.auth=null,this.initialized=!1}async init(){if(!this.initialized)try{if(!firebase||!firebase.firestore||!firebase.auth)throw new Error("Firebase not initialized");this.db=firebase.firestore(),this.auth=firebase.auth(),this.initialized=!0}catch(t){throw t}}async createSubmission(t,e){await this.init();const i=this.auth.currentUser;if(!i)throw new Error("User must be authenticated to create submissions");const s=`sub_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,r=firebase.firestore.FieldValue.serverTimestamp(),a={id:s,type:e,status:"pending",data:t,submittedBy:i.uid,submittedByName:i.displayName||i.email,submittedByEmail:i.email,submittedByAvatar:i.photoURL||null,submittedAt:r,updatedAt:r,reviewedBy:null,reviewedByName:null,reviewedAt:null,reviewNotes:null,rejectionReason:null,mythology:t.mythology||null,entityName:t.name||t.title||"Untitled",views:0,flags:0};try{return await this.db.collection("submissions").doc(s).set(a),await this.createNotification({userId:i.uid,type:"submission_created",title:"Submission Created",message:`Your ${e} submission "${a.entityName}" has been submitted for review.`,link:`/dashboard.html?highlight=${s}`,data:{submissionId:s,submissionType:e}}),{success:!0,submissionId:s,submission:a}}catch(t){throw new Error("Failed to create submission: "+t.message)}}async updateSubmission(t,e){await this.init();const i=this.auth.currentUser;if(!i)throw new Error("User must be authenticated");try{const s=this.db.collection("submissions").doc(t),r=await s.get();if(!r.exists)throw new Error("Submission not found");const a=r.data();if(a.submittedBy!==i.uid)throw new Error("You can only update your own submissions");if(!["pending","rejected"].includes(a.status))throw new Error("Cannot update approved or processing submissions");const o={data:e,updatedAt:firebase.firestore.FieldValue.serverTimestamp()};return"rejected"===a.status&&(o.status="pending",o.rejectionReason=null),await s.update(o),{success:!0,submissionId:t}}catch(t){throw t}}async deleteSubmission(t){await this.init();const e=this.auth.currentUser;if(!e)throw new Error("User must be authenticated");try{const i=this.db.collection("submissions").doc(t),s=await i.get();if(!s.exists)throw new Error("Submission not found");const r=s.data(),a=await this.db.collection("users").doc(e.uid).get(),o=a.exists&&"admin"===a.data().role;if(r.submittedBy!==e.uid&&!o)throw new Error("You can only delete your own submissions");if(!["pending","rejected"].includes(r.status)&&!o)throw new Error("Cannot delete approved submissions");return await i.delete(),{success:!0}}catch(t){throw t}}async getUserSubmissions(t={}){await this.init();const e=this.auth.currentUser;if(!e)throw new Error("User must be authenticated");try{let i=this.db.collection("submissions").where("submittedBy","==",e.uid);return t.status&&(i=i.where("status","==",t.status)),t.type&&(i=i.where("type","==",t.type)),i=i.orderBy("submittedAt","desc"),t.limit&&(i=i.limit(t.limit)),(await i.get()).docs.map(t=>({id:t.id,...t.data()}))}catch(t){throw t}}async getUserStats(){await this.init();const t=this.auth.currentUser;if(!t)throw new Error("User must be authenticated");try{const[e,i,s]=await Promise.all([this.db.collection("submissions").where("submittedBy","==",t.uid).where("status","==","pending").get(),this.db.collection("submissions").where("submittedBy","==",t.uid).where("status","==","approved").get(),this.db.collection("submissions").where("submittedBy","==",t.uid).where("status","==","rejected").get()]),r=e.size+i.size+s.size,a=r>0?(i.size/r*100).toFixed(1):0;return{total:r,pending:e.size,approved:i.size,rejected:s.size,approvalRate:a}}catch(t){return{total:0,pending:0,approved:0,rejected:0,approvalRate:0}}}async getPendingSubmissions(t={}){await this.init();const e=this.auth.currentUser;if(!e)throw new Error("User must be authenticated");const i=await this.db.collection("users").doc(e.uid).get();if(!i.exists||"admin"!==i.data().role)throw new Error("Admin access required");try{let e=this.db.collection("submissions");e=t.status?e.where("status","==",t.status):e.where("status","==","pending"),t.type&&(e=e.where("type","==",t.type)),t.mythology&&(e=e.where("mythology","==",t.mythology)),e=e.orderBy("submittedAt",t.sortOrder||"desc"),t.limit&&(e=e.limit(t.limit)),t.startAfter&&(e=e.startAfter(t.startAfter));const i=await e.get();return{submissions:i.docs.map(t=>({id:t.id,...t.data()})),lastDoc:i.docs[i.docs.length-1],hasMore:i.docs.length===t.limit}}catch(t){throw t}}async approveSubmission(t,e={}){await this.init();const i=this.auth.currentUser;if(!i)throw new Error("User must be authenticated");const s=await this.db.collection("users").doc(i.uid).get();if(!s.exists||"admin"!==s.data().role)throw new Error("Admin access required");try{const s=this.db.collection("submissions").doc(t),r=await s.get();if(!r.exists)throw new Error("Submission not found");const a=r.data(),o=ENTITY_COLLECTIONS[a.type];if(!o)throw new Error("Invalid submission type: "+a.type);const n={...a.data,...e.modifications||{},contributedBy:a.submittedBy,contributorName:a.submittedByName,contributedAt:a.submittedAt,approvedBy:i.uid,approvedByName:i.displayName||i.email,approvedAt:firebase.firestore.FieldValue.serverTimestamp(),status:"approved",isUserContributed:!0},d=e.entityId||`${a.type}_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;return await this.db.collection(o).doc(d).set(n),await s.update({status:"approved",reviewedBy:i.uid,reviewedByName:i.displayName||i.email,reviewedAt:firebase.firestore.FieldValue.serverTimestamp(),reviewNotes:e.notes||null,approvedEntityId:d,approvedEntityCollection:o}),await this.createNotification({userId:a.submittedBy,type:"submission_approved",title:"Submission Approved!",message:`Your ${a.type} submission "${a.entityName}" has been approved and published.`,link:`/${o}/${d}.html`,data:{submissionId:t,entityId:d,entityCollection:o}}),{success:!0,entityId:d,entityCollection:o}}catch(t){throw t}}async rejectSubmission(t,e){await this.init();const i=this.auth.currentUser;if(!i)throw new Error("User must be authenticated");const s=await this.db.collection("users").doc(i.uid).get();if(!s.exists||"admin"!==s.data().role)throw new Error("Admin access required");try{const s=this.db.collection("submissions").doc(t),r=await s.get();if(!r.exists)throw new Error("Submission not found");const a=r.data();return await s.update({status:"rejected",reviewedBy:i.uid,reviewedByName:i.displayName||i.email,reviewedAt:firebase.firestore.FieldValue.serverTimestamp(),rejectionReason:e}),await this.createNotification({userId:a.submittedBy,type:"submission_rejected",title:"Submission Needs Revision",message:`Your ${a.type} submission "${a.entityName}" needs revision. Reason: ${e}`,link:`/dashboard.html?highlight=${t}`,data:{submissionId:t,reason:e}}),{success:!0}}catch(t){throw t}}async bulkApprove(t){const e={success:[],failed:[]};for(const i of t)try{await this.approveSubmission(i),e.success.push(i)}catch(t){e.failed.push({id:i,error:t.message})}return e}async bulkReject(t,e){const i={success:[],failed:[]};for(const s of t)try{await this.rejectSubmission(s,e),i.success.push(s)}catch(t){i.failed.push({id:s,error:t.message})}return i}async createNotification(t){try{const e=`notif_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;await this.db.collection("notifications").doc(e).set({id:e,userId:t.userId,type:t.type,title:t.title,message:t.message,link:t.link||null,data:t.data||null,read:!1,createdAt:firebase.firestore.FieldValue.serverTimestamp()})}catch(t){}}async getUserNotifications(t={}){await this.init();const e=this.auth.currentUser;if(!e)throw new Error("User must be authenticated");try{let i=this.db.collection("notifications").where("userId","==",e.uid);return t.unreadOnly&&(i=i.where("read","==",!1)),i=i.orderBy("createdAt","desc"),t.limit&&(i=i.limit(t.limit)),(await i.get()).docs.map(t=>({id:t.id,...t.data()}))}catch(t){throw t}}async markNotificationAsRead(t){await this.init();const e=this.auth.currentUser;if(!e)throw new Error("User must be authenticated");try{const i=this.db.collection("notifications").doc(t),s=await i.get();if(!s.exists)throw new Error("Notification not found");if(s.data().userId!==e.uid)throw new Error("Cannot access other users' notifications");await i.update({read:!0,readAt:firebase.firestore.FieldValue.serverTimestamp()})}catch(t){throw t}}async markAllNotificationsAsRead(){await this.init();const t=this.auth.currentUser;if(!t)throw new Error("User must be authenticated");try{const e=await this.db.collection("notifications").where("userId","==",t.uid).where("read","==",!1).get(),i=this.db.batch();e.docs.forEach(t=>{i.update(t.ref,{read:!0,readAt:firebase.firestore.FieldValue.serverTimestamp()})}),await i.commit()}catch(t){throw t}}async checkDuplicates(t,e,i){await this.init();try{const s=ENTITY_COLLECTIONS[i];if(!s)return[];const[r,a]=await Promise.all([this.db.collection(s).where("name","==",t).where("mythology","==",e).get(),this.db.collection("submissions").where("entityName","==",t).where("mythology","==",e).where("type","==",i).where("status","==","pending").get()]),o=[];return r.forEach(t=>{o.push({type:"existing",id:t.id,data:t.data()})}),a.forEach(t=>{o.push({type:"pending",id:t.id,data:t.data()})}),o}catch(t){return[]}}}window.submissionWorkflow=new SubmissionWorkflow,"undefined"!=typeof module&&module.exports&&(module.exports=SubmissionWorkflow);