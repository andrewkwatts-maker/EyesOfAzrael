class EnhancedCorpusSearch extends CorpusSearch{constructor(e){super(e),this.persistentCache=null,this.initPersistentCache(),this.searchHistory=this.loadSearchHistory(),this.maxHistorySize=50,this.metrics={searches:0,cacheHits:0,averageTime:0}}async initPersistentCache(){if(window.indexedDB)return new Promise((e,s)=>{const t=indexedDB.open("CorpusSearchCache",1);t.onerror=()=>s(t.error),t.onsuccess=()=>{this.persistentCache=t.result,e()},t.onupgradeneeded=e=>{const s=e.target.result;s.objectStoreNames.contains("searches")||s.createObjectStore("searches",{keyPath:"key"}).createIndex("timestamp","timestamp",{unique:!1})}})}async search(e,s={}){const t=performance.now(),r=this.getCacheKey(e,s);if(this.persistentCache){const e=await this.getPersistentCache(r);if(e&&Date.now()-e.timestamp<this.cacheTimeout)return this.metrics.cacheHits++,e.results}if(this.searchCache.has(r)){const e=this.searchCache.get(r);if(Date.now()-e.timestamp<this.cacheTimeout)return this.metrics.cacheHits++,e.results}const i=await super.search(e,s),a=performance.now()-t;return this.metrics.searches++,this.metrics.averageTime=(this.metrics.averageTime*(this.metrics.searches-1)+a)/this.metrics.searches,this.persistentCache&&await this.setPersistentCache(r,i),this.addToHistory(e,s,i.total),i}async getPersistentCache(e){return this.persistentCache?new Promise((s,t)=>{const r=this.persistentCache.transaction(["searches"],"readonly").objectStore("searches").get(e);r.onsuccess=()=>s(r.result),r.onerror=()=>s(null)}):null}async setPersistentCache(e,s){if(this.persistentCache)return new Promise((t,r)=>{const i=this.persistentCache.transaction(["searches"],"readwrite").objectStore("searches").put({key:e,results:s,timestamp:Date.now()});i.onsuccess=()=>t(),i.onerror=()=>t()})}loadSearchHistory(){try{const e=localStorage.getItem("searchHistory");return e?JSON.parse(e):[]}catch(e){return[]}}saveSearchHistory(){try{localStorage.setItem("searchHistory",JSON.stringify(this.searchHistory))}catch(e){}}addToHistory(e,s,t){const r={query:e,options:s,resultCount:t,timestamp:Date.now()};this.searchHistory=this.searchHistory.filter(s=>s.query!==e),this.searchHistory.unshift(r),this.searchHistory.length>this.maxHistorySize&&(this.searchHistory=this.searchHistory.slice(0,this.maxHistorySize)),this.saveSearchHistory()}getHistory(e=10){return this.searchHistory.slice(0,e)}clearHistory(){this.searchHistory=[],this.saveSearchHistory()}getPopularSearches(e=10){const s={};return this.searchHistory.forEach(e=>{const t=e.query.toLowerCase();s[t]=(s[t]||0)+1}),Object.entries(s).sort((e,s)=>s[1]-e[1]).slice(0,e).map(([e,s])=>({query:e,count:s}))}getMetrics(){return{...this.metrics,cacheHitRate:this.metrics.searches>0?(this.metrics.cacheHits/this.metrics.searches*100).toFixed(2)+"%":"0%",averageTime:this.metrics.averageTime.toFixed(2)+"ms"}}async prefetchPopularEntities(){const e=["zeus","odin","ra","shiva","buddha","jesus","muhammad","krishna","thor","apollo"].map(e=>this.search(e,{mode:"generic",limit:10}));await Promise.all(e)}async clearAllCaches(){if(this.clearCache(),this.persistentCache)return new Promise(e=>{const s=this.persistentCache.transaction(["searches"],"readwrite").objectStore("searches").clear();s.onsuccess=()=>e(),s.onerror=()=>e()})}}"undefined"!=typeof module&&module.exports&&(module.exports=EnhancedCorpusSearch);