rules_version = '2';

/**
 * Firestore Security Rules
 * Eyes of Azrael - Complete System
 *
 * SECURITY MODEL:
 * - Public read access for published content
 * - Authenticated write access
 * - Ownership enforcement
 * - Moderation support (roles: user, moderator, admin)
 * - Rate limiting (read/write limits per user)
 * - DDoS protection via Firebase App Check
 * - Spam prevention
 *
 * DEPLOYMENT:
 *   firebase deploy --only firestore:rules
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // ===== HELPER FUNCTIONS =====

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function getUserRole() {
      return isAuthenticated() ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role : 'guest';
    }

    function isModerator() {
      return getUserRole() in ['moderator', 'admin'];
    }

    function isAdmin() {
      return getUserRole() == 'admin';
    }

    // Admin bypass for all rate limits
    function isAdminEmail() {
      return isAuthenticated() && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // Rate limiting helpers
    function isRateLimited() {
      // Check if user has exceeded rate limits
      // For anonymous: 50 reads/hour
      // For authenticated: 500 reads/hour
      // For admin: unlimited
      return !isAdminEmail() && exists(/databases/$(database)/documents/system/rate_limits/$(request.auth != null ? request.auth.uid : request.path));
    }

    // Query size validation
    function isQuerySizeValid(maxLimit) {
      return !request.query.limit.hasOnly([]) && request.query.limit <= maxLimit;
    }

    // ===== USERS COLLECTION =====
    // Path: /users/{userId}

    match /users/{userId} {
      // Anyone can read user profiles
      allow read: if true;

      // Users can create their own profile
      allow create: if isOwner(userId)
                    && request.resource.data.keys().hasAll(['email', 'displayName', 'createdAt'])
                    && request.resource.data.email is string
                    && request.resource.data.displayName is string;

      // Users can update their own profile (not email or role)
      allow update: if isOwner(userId)
                    && request.resource.data.email == resource.data.email
                    && (!('role' in request.resource.data) || request.resource.data.role == resource.data.role);

      // No deletions (prevents orphaned content)
      allow delete: if false;
    }

    // ===== THEORIES COLLECTION =====
    // Path: /theories/{theoryId}
    // User submissions: theories and asset contributions

    match /theories/{theoryId} {
      function isValidTheory() {
        return request.resource.data.keys().hasAll(['title', 'summary', 'content', 'authorId', 'status', 'page', 'contributionType'])
               && request.resource.data.title is string
               && request.resource.data.title.size() >= 3
               && request.resource.data.title.size() <= 200
               && request.resource.data.summary is string
               && request.resource.data.status in ['draft', 'published', 'archived']
               && request.resource.data.page is string
               && request.resource.data.contributionType is string
               && request.resource.data.authorId == request.auth.uid;
      }

      // Public read for published, owner read for drafts
      allow read: if resource.data.status == 'published'
                  || isOwner(resource.data.authorId)
                  || isModerator();

      // Authenticated users can create theories
      allow create: if isAuthenticated() && isValidTheory();

      // Owner can update (cannot change authorId)
      allow update: if isOwner(resource.data.authorId)
                    && request.resource.data.authorId == resource.data.authorId
                    && isValidTheory();

      // Owner or moderator can delete
      allow delete: if isOwner(resource.data.authorId) || isModerator();

      // Comments subcollection
      match /comments/{commentId} {
        allow read: if true;
        allow create: if isAuthenticated()
                      && request.resource.data.authorId == request.auth.uid
                      && request.resource.data.content is string
                      && request.resource.data.content.size() <= 2000;
        allow update: if isOwner(resource.data.authorId)
                      && request.resource.data.authorId == resource.data.authorId;
        allow delete: if isOwner(resource.data.authorId) || isModerator();
      }

      // Votes subcollection
      match /votes/{voteUserId} {
        allow read: if true;
        allow write: if isAuthenticated()
                     && request.auth.uid == voteUserId
                     && (request.resource.data.vote in [1, -1] || request.resource.data.size() == 0);
      }
    }

    // ===== ASSETS COLLECTION =====
    // Path: /assets/{assetId}
    // Official content + approved user contributions

    match /assets/{assetId} {
      function isValidAsset() {
        return request.resource.data.keys().hasAll(['name', 'assetType', 'mythology', 'status'])
               && request.resource.data.name is string
               && request.resource.data.name.size() >= 1
               && request.resource.data.assetType in ['deity', 'hero', 'creature', 'place', 'item', 'herb', 'text', 'concept', 'event']
               && request.resource.data.mythology is string
               && request.resource.data.status in ['draft', 'published', 'approved'];
      }

      // Public read for published/approved
      allow read: if resource.data.status in ['published', 'approved']
                  || (isAuthenticated() && resource.data.contributedBy == request.auth.uid)
                  || isModerator();

      // Authenticated users can create asset proposals
      allow create: if isAuthenticated()
                    && isValidAsset()
                    && (!('isOfficial' in request.resource.data) || request.resource.data.isOfficial == false);

      // Owner or moderator can update
      allow update: if (isAuthenticated() && resource.data.contributedBy == request.auth.uid)
                    || isModerator()
                    && isValidAsset();

      // Only moderators can delete assets
      allow delete: if isModerator();

      // Comments subcollection
      match /comments/{commentId} {
        allow read: if true;
        allow create: if isAuthenticated()
                      && request.resource.data.authorId == request.auth.uid;
        allow update: if isOwner(resource.data.authorId);
        allow delete: if isOwner(resource.data.authorId) || isModerator();
      }

      // Votes subcollection
      match /votes/{voteUserId} {
        allow read: if true;
        allow write: if isAuthenticated() && request.auth.uid == voteUserId;
      }

      // Edits subcollection (edit history)
      match /edits/{editId} {
        allow read: if true;
        allow create: if isAuthenticated();
        allow update, delete: if isModerator();
      }
    }

    // ===== PAGES COLLECTION =====
    // Path: /pages/{pageId}
    // Site structure for dynamic page generation

    match /pages/{pageId} {
      // Anyone can read published pages
      allow read: if resource.data.status == 'published' || isModerator();

      // Only admins can create/update/delete pages
      allow create, update, delete: if isAdmin();
    }

    // ===== TAXONOMIES COLLECTION =====
    // Path: /taxonomies/{taxonomyId}

    match /taxonomies/{taxonomyId} {
      // Anyone can read taxonomies
      allow read: if true;

      // Only admins can modify
      allow write: if isAdmin();
    }

    // ===== VOTES COLLECTION =====
    // Path: /votes/{voteId}
    // Global vote tracking

    match /votes/{voteId} {
      // Anyone can read aggregated vote data
      allow read: if true;

      // Users can only create/update/delete their own votes
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.vote in [1, -1];

      allow update: if isAuthenticated()
                    && resource.data.userId == request.auth.uid
                    && request.resource.data.userId == request.auth.uid;

      allow delete: if isAuthenticated()
                    && resource.data.userId == request.auth.uid;
    }

    // ===== BOOKMARKS COLLECTION =====
    // Path: /bookmarks/{bookmarkId}

    match /bookmarks/{bookmarkId} {
      // Users can only read their own bookmarks
      allow read: if isAuthenticated()
                  && resource.data.userId == request.auth.uid;

      // Users can create their own bookmarks
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid;

      // Users can update their own bookmarks
      allow update: if isAuthenticated()
                    && resource.data.userId == request.auth.uid
                    && request.resource.data.userId == request.auth.uid;

      // Users can delete their own bookmarks
      allow delete: if isAuthenticated()
                    && resource.data.userId == request.auth.uid;
    }

    // ===== COMMENTS COLLECTION =====
    // Path: /comments/{commentId}
    // Global comments (alternative to subcollections)

    match /comments/{commentId} {
      // Anyone can read published comments
      allow read: if resource.data.status == 'published' || isModerator();

      // Authenticated users can create comments
      allow create: if isAuthenticated()
                    && request.resource.data.authorId == request.auth.uid
                    && request.resource.data.content is string
                    && request.resource.data.content.size() <= 2000;

      // Owner can update within 15 minutes
      allow update: if isOwner(resource.data.authorId)
                    && request.resource.data.authorId == resource.data.authorId
                    && request.time < resource.data.createdAt + duration.value(15, 'm');

      // Owner or moderator can delete
      allow delete: if isOwner(resource.data.authorId) || isModerator();
    }

    // ===== NOTIFICATIONS COLLECTION =====
    // Path: /notifications/{notificationId}

    match /notifications/{notificationId} {
      // Users can only read their own notifications
      allow read: if isAuthenticated()
                  && resource.data.userId == request.auth.uid;

      // System can create notifications (via Cloud Functions)
      // Users can't create their own
      allow create: if false;

      // Users can mark their notifications as read
      allow update: if isAuthenticated()
                    && resource.data.userId == request.auth.uid
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.keys().hasOnly(['read', 'readAt']);

      // Users can delete their own notifications
      allow delete: if isAuthenticated()
                    && resource.data.userId == request.auth.uid;
    }

    // ===== SVG GENERATION COLLECTION =====
    // Path: /svgGeneration/{svgId}
    // Track AI-generated SVG graphics

    match /svgGeneration/{svgId} {
      // Anyone can read (for browsing generated SVGs)
      allow read: if true;

      // Authenticated users can create
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.prompt is string
                    && request.resource.data.svgCode is string;

      // Owner can update (to track usage)
      allow update: if isOwner(resource.data.userId);

      // Owner can delete
      allow delete: if isOwner(resource.data.userId);

      // Vote subcollection for SVG quality
      match /votes/{voteUserId} {
        allow read: if true;
        allow write: if isAuthenticated() && request.auth.uid == voteUserId;
      }
    }

    // ===== MYTHOLOGIES COLLECTION =====
    // Path: /mythologies/{mythologyId}
    // Core mythology metadata (Greek, Hindu, Norse, etc.)

    match /mythologies/{mythologyId} {
      // Anyone can read mythologies
      allow read: if true;

      // Only author (Andrew Watts) can create/update/delete
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== DEITIES COLLECTION =====
    // Path: /deities/{deityId}
    // Full deity information with domains, symbols, relationships

    match /deities/{deityId} {
      // Anyone can read deities (with query limits)
      allow get: if true;
      allow list: if request.query.limit <= 100;

      // Only author can create/update/delete official content
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== HEROES COLLECTION =====
    // Path: /heroes/{heroId}

    match /heroes/{heroId} {
      allow get: if true;
      allow list: if request.query.limit <= 100;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== CREATURES COLLECTION =====
    // Path: /creatures/{creatureId}

    match /creatures/{creatureId} {
      allow get: if true;
      allow list: if request.query.limit <= 100;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== COSMOLOGY COLLECTION =====
    // Path: /cosmology/{cosmologyId}

    match /cosmology/{cosmologyId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== HERBS COLLECTION =====
    // Path: /herbs/{herbId}

    match /herbs/{herbId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== RITUALS COLLECTION =====
    // Path: /rituals/{ritualId}

    match /rituals/{ritualId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== TEXTS COLLECTION =====
    // Path: /texts/{textId}

    match /texts/{textId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== ARCHETYPES COLLECTION =====
    // Path: /archetypes/{archetypeId}
    // Cross-mythology archetypes (Sky Father, Trickster, etc.)

    match /archetypes/{archetypeId} {
      // Anyone can read archetypes
      allow read: if true;

      // Only author can create/update/delete
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== SEARCH INDEX COLLECTION =====
    // Path: /search_index/{searchId}
    // Searchable entries for full-text search

    match /search_index/{searchId} {
      // Anyone can read search index
      allow read: if true;

      // Only author can create/update/delete
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== CROSS REFERENCES COLLECTION =====
    // Path: /cross_references/{refId}

    match /cross_references/{refId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== SVG GRAPHICS COLLECTION =====
    // Path: /svg_graphics/{svgId}
    // Store SVG diagrams and visualizations

    match /svg_graphics/{svgId} {
      allow read: if true;

      // Users can create their own SVGs
      allow create: if isAuthenticated()
        && request.resource.data.authorId == request.auth.uid;

      // Users can update their own, author can update any
      allow update: if isAuthenticated()
        && (request.resource.data.authorId == request.auth.uid
            || request.auth.token.email == 'andrewkwatts@gmail.com');

      // Users can delete their own, author can delete any
      allow delete: if isAuthenticated()
        && (resource.data.authorId == request.auth.uid
            || request.auth.token.email == 'andrewkwatts@gmail.com');
    }

    // ===== USER THEORIES COLLECTION =====
    // Path: /user_theories/{theoryId}
    // User-submitted theories (readable/editable by users)

    match /user_theories/{theoryId} {
      function isValidUserTheory() {
        return request.resource.data.keys().hasAll(['title', 'content', 'authorId', 'status'])
               && request.resource.data.title is string
               && request.resource.data.authorId == request.auth.uid;
      }

      // Public read for published theories
      allow read: if resource.data.status == 'published'
                  || isOwner(resource.data.authorId)
                  || request.auth.token.email == 'andrewkwatts@gmail.com';

      // Authenticated users can create theories
      allow create: if isAuthenticated() && isValidUserTheory();

      // Users can update their own theories, author can update any
      allow update: if isAuthenticated()
                    && (isOwner(resource.data.authorId)
                        || request.auth.token.email == 'andrewkwatts@gmail.com')
                    && isValidUserTheory();

      // Users can delete their own, author can delete any
      allow delete: if isAuthenticated()
                    && (isOwner(resource.data.authorId)
                        || request.auth.token.email == 'andrewkwatts@gmail.com');
    }

    // ===== SUBMISSIONS COLLECTION =====
    // Path: /submissions/{submissionId}
    // User submissions/appendments to existing content

    match /submissions/{submissionId} {
      function isValidSubmission() {
        return request.resource.data.keys().hasAll(['title', 'content', 'parentCollection', 'parentDocumentId', 'contentType', 'submittedBy', 'status'])
               && request.resource.data.title is string
               && request.resource.data.title.size() >= 3
               && request.resource.data.title.size() <= 200
               && request.resource.data.content is string
               && request.resource.data.content.size() >= 10
               && request.resource.data.content.size() <= 5000
               && request.resource.data.parentCollection is string
               && request.resource.data.parentDocumentId is string
               && request.resource.data.contentType is string
               && request.resource.data.submittedBy == request.auth.uid
               && request.resource.data.status in ['pending', 'approved', 'rejected'];
      }

      // Anyone can read approved submissions
      allow get: if resource.data.status == 'approved';
      allow list: if resource.data.status == 'approved'
                  && request.query.limit <= 50;

      // Users can read their own submissions regardless of status
      allow read: if isAuthenticated()
                  && resource.data.submittedBy == request.auth.uid;

      // Admin can read all submissions
      allow read: if isAdminEmail();

      // Authenticated users can create submissions
      allow create: if isAuthenticated()
                    && isValidSubmission()
                    && request.resource.data.status == 'pending';

      // Users can update their own pending submissions
      allow update: if isAuthenticated()
                    && resource.data.submittedBy == request.auth.uid
                    && resource.data.status == 'pending'
                    && request.resource.data.submittedBy == request.auth.uid
                    && request.resource.data.status == 'pending'
                    && isValidSubmission();

      // Admin can approve/reject submissions
      allow update: if isAdminEmail()
                    && request.resource.data.submittedBy == resource.data.submittedBy;

      // Users can delete their own pending submissions
      allow delete: if isAuthenticated()
                    && resource.data.submittedBy == request.auth.uid
                    && resource.data.status == 'pending';

      // Admin can delete any submission
      allow delete: if isAdminEmail();
    }

    // ===== SYSTEM COLLECTION =====
    // Path: /system/{document}
    // Rate limiting, blocked IPs, security logs

    match /system/rate_limits/{identifier} {
      // Only Cloud Functions can read/write rate limits
      allow read, write: if false;
    }

    match /system/blocked_ips/{ipHash} {
      // Only Cloud Functions can read/write blocked IPs
      allow read, write: if false;
    }

    match /system/security_logs/{logId} {
      // Only admin can read security logs
      allow read: if isAdminEmail();
      allow write: if false;
    }

    match /system/abuse_reports/{reportId} {
      // Authenticated users can report abuse
      allow read: if isAdminEmail();
      allow create: if isAuthenticated()
                    && request.resource.data.reporterId == request.auth.uid;
      allow update, delete: if false;
    }

    // ===== DENY ALL OTHER PATHS =====
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
