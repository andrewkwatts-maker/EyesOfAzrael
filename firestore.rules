rules_version = '2';

/**
 * Firestore Security Rules
 * Eyes of Azrael - Complete System
 *
 * SECURITY MODEL:
 * - Public read access for published content
 * - Authenticated write access
 * - Ownership enforcement
 * - Moderation support (roles: user, moderator, admin)
 * - Rate limiting (read/write limits per user)
 * - DDoS protection via Firebase App Check
 * - Spam prevention
 *
 * DEPLOYMENT:
 *   firebase deploy --only firestore:rules
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // ===== HELPER FUNCTIONS =====

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function getUserRole() {
      return isAuthenticated() ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role : 'guest';
    }

    function isModerator() {
      return getUserRole() in ['moderator', 'admin'];
    }

    function isAdmin() {
      return getUserRole() == 'admin';
    }

    // Admin bypass for all rate limits
    function isAdminEmail() {
      return isAuthenticated() && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // Rate limiting helpers
    function isRateLimited() {
      // Check if user has exceeded rate limits
      // For anonymous: 50 reads/hour
      // For authenticated: 500 reads/hour
      // For admin: unlimited
      return !isAdminEmail() && exists(/databases/$(database)/documents/system/rate_limits/$(request.auth != null ? request.auth.uid : request.path));
    }

    // Query size validation
    function isQuerySizeValid(maxLimit) {
      return !request.query.limit.hasOnly([]) && request.query.limit <= maxLimit;
    }

    // ===== USERS COLLECTION =====
    // Path: /users/{userId}

    match /users/{userId} {
      // Anyone can read user profiles
      allow read: if true;

      // Users can create their own profile
      allow create: if isOwner(userId)
                    && request.resource.data.keys().hasAll(['email', 'displayName', 'createdAt'])
                    && request.resource.data.email is string
                    && request.resource.data.displayName is string;

      // Users can update their own profile (not email or role)
      allow update: if isOwner(userId)
                    && request.resource.data.email == resource.data.email
                    && (!('role' in request.resource.data) || request.resource.data.role == resource.data.role);

      // No deletions (prevents orphaned content)
      allow delete: if false;
    }

    // ===== THEORIES COLLECTION =====
    // Path: /theories/{theoryId}
    // User submissions: theories and asset contributions

    match /theories/{theoryId} {
      function isValidTheory() {
        return request.resource.data.keys().hasAll(['title', 'summary', 'content', 'authorId', 'status', 'page', 'contributionType'])
               && request.resource.data.title is string
               && request.resource.data.title.size() >= 3
               && request.resource.data.title.size() <= 200
               && request.resource.data.summary is string
               && request.resource.data.status in ['draft', 'published', 'archived']
               && request.resource.data.page is string
               && request.resource.data.contributionType is string
               && request.resource.data.authorId == request.auth.uid;
      }

      // Public read for published, owner read for drafts
      allow read: if resource.data.status == 'published'
                  || isOwner(resource.data.authorId)
                  || isModerator();

      // Authenticated users can create theories
      allow create: if isAuthenticated() && isValidTheory();

      // Owner can update (cannot change authorId)
      allow update: if isOwner(resource.data.authorId)
                    && request.resource.data.authorId == resource.data.authorId
                    && isValidTheory();

      // Owner or moderator can delete
      allow delete: if isOwner(resource.data.authorId) || isModerator();

      // Comments subcollection
      match /comments/{commentId} {
        allow read: if true;
        allow create: if isAuthenticated()
                      && request.resource.data.authorId == request.auth.uid
                      && request.resource.data.content is string
                      && request.resource.data.content.size() <= 2000;
        allow update: if isOwner(resource.data.authorId)
                      && request.resource.data.authorId == resource.data.authorId;
        allow delete: if isOwner(resource.data.authorId) || isModerator();
      }

      // Votes subcollection
      match /votes/{voteUserId} {
        allow read: if true;
        allow write: if isAuthenticated()
                     && request.auth.uid == voteUserId
                     && (request.resource.data.vote in [1, -1] || request.resource.data.size() == 0);
      }
    }

    // ===== ASSETS COLLECTION =====
    // Path: /assets/{assetId}
    // Official content + approved user contributions

    match /assets/{assetId} {
      function isValidAsset() {
        return request.resource.data.keys().hasAll(['name', 'assetType', 'mythology', 'status'])
               && request.resource.data.name is string
               && request.resource.data.name.size() >= 1
               && request.resource.data.assetType in ['deity', 'hero', 'creature', 'place', 'item', 'herb', 'text', 'concept', 'event']
               && request.resource.data.mythology is string
               && request.resource.data.status in ['draft', 'published', 'approved'];
      }

      // Public read for published/approved
      allow read: if resource.data.status in ['published', 'approved']
                  || (isAuthenticated() && resource.data.contributedBy == request.auth.uid)
                  || isModerator();

      // Authenticated users can create asset proposals
      allow create: if isAuthenticated()
                    && isValidAsset()
                    && (!('isOfficial' in request.resource.data) || request.resource.data.isOfficial == false);

      // Owner or moderator can update
      allow update: if ((isAuthenticated() && resource.data.contributedBy == request.auth.uid)
                    || isModerator())
                    && isValidAsset();

      // Only moderators can delete assets
      allow delete: if isModerator();

      // Comments subcollection
      match /comments/{commentId} {
        allow read: if true;
        allow create: if isAuthenticated()
                      && request.resource.data.authorId == request.auth.uid;
        allow update: if isOwner(resource.data.authorId);
        allow delete: if isOwner(resource.data.authorId) || isModerator();
      }

      // Votes subcollection
      match /votes/{voteUserId} {
        allow read: if true;
        allow write: if isAuthenticated() && request.auth.uid == voteUserId;
      }

      // Edits subcollection (edit history)
      match /edits/{editId} {
        allow read: if true;
        allow create: if isAuthenticated();
        allow update, delete: if isModerator();
      }
    }

    // ===== PAGES COLLECTION =====
    // Path: /pages/{pageId}
    // Site structure for dynamic page generation

    match /pages/{pageId} {
      // Anyone can read published pages
      allow read: if resource.data.status == 'published' || isModerator();

      // Only admins can create/update/delete pages
      allow create, update, delete: if isAdmin();
    }

    // ===== TAXONOMIES COLLECTION =====
    // Path: /taxonomies/{taxonomyId}

    match /taxonomies/{taxonomyId} {
      // Anyone can read taxonomies
      allow read: if true;

      // Only admins can modify
      allow write: if isAdmin();
    }

    // ===== VOTES COLLECTION =====
    // Path: /votes/{voteId}
    // Global vote tracking

    match /votes/{voteId} {
      // Anyone can read aggregated vote data
      allow read: if true;

      // Users can only create/update/delete their own votes
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.vote in [1, -1];

      allow update: if isAuthenticated()
                    && resource.data.userId == request.auth.uid
                    && request.resource.data.userId == request.auth.uid;

      allow delete: if isAuthenticated()
                    && resource.data.userId == request.auth.uid;
    }

    // ===== BOOKMARKS COLLECTION =====
    // Path: /bookmarks/{bookmarkId}

    match /bookmarks/{bookmarkId} {
      // Users can only read their own bookmarks
      allow read: if isAuthenticated()
                  && resource.data.userId == request.auth.uid;

      // Users can create their own bookmarks
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid;

      // Users can update their own bookmarks
      allow update: if isAuthenticated()
                    && resource.data.userId == request.auth.uid
                    && request.resource.data.userId == request.auth.uid;

      // Users can delete their own bookmarks
      allow delete: if isAuthenticated()
                    && resource.data.userId == request.auth.uid;
    }

    // ===== COMMENTS COLLECTION =====
    // Path: /comments/{commentId}
    // Global comments (alternative to subcollections)

    match /comments/{commentId} {
      // Anyone can read published comments
      allow read: if resource.data.status == 'published' || isModerator();

      // Authenticated users can create comments
      allow create: if isAuthenticated()
                    && request.resource.data.authorId == request.auth.uid
                    && request.resource.data.content is string
                    && request.resource.data.content.size() <= 2000;

      // Owner can update within 15 minutes
      allow update: if isOwner(resource.data.authorId)
                    && request.resource.data.authorId == resource.data.authorId
                    && request.time < resource.data.createdAt + duration.value(15, 'm');

      // Owner or moderator can delete
      allow delete: if isOwner(resource.data.authorId) || isModerator();
    }

    // ===== NOTIFICATIONS COLLECTION =====
    // Path: /notifications/{notificationId}

    match /notifications/{notificationId} {
      // Users can only read their own notifications
      allow read: if isAuthenticated()
                  && resource.data.userId == request.auth.uid;

      // System can create notifications (via Cloud Functions)
      // Users can't create their own
      allow create: if false;

      // Users can mark their notifications as read
      allow update: if isAuthenticated()
                    && resource.data.userId == request.auth.uid
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.keys().hasOnly(['read', 'readAt']);

      // Users can delete their own notifications
      allow delete: if isAuthenticated()
                    && resource.data.userId == request.auth.uid;
    }

    // ===== SVG GENERATION COLLECTION =====
    // Path: /svgGeneration/{svgId}
    // Track AI-generated SVG graphics

    match /svgGeneration/{svgId} {
      // Anyone can read (for browsing generated SVGs)
      allow read: if true;

      // Authenticated users can create
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.prompt is string
                    && request.resource.data.svgCode is string;

      // Owner can update (to track usage)
      allow update: if isOwner(resource.data.userId);

      // Owner can delete
      allow delete: if isOwner(resource.data.userId);

      // Vote subcollection for SVG quality
      match /votes/{voteUserId} {
        allow read: if true;
        allow write: if isAuthenticated() && request.auth.uid == voteUserId;
      }
    }

    // ===== MYTHOLOGIES COLLECTION =====
    // Path: /mythologies/{mythologyId}
    // Core mythology metadata (Greek, Hindu, Norse, etc.)

    match /mythologies/{mythologyId} {
      // Anyone can read mythologies
      allow read: if true;

      // Only author (Andrew Watts) can create/update/delete
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== DEITIES COLLECTION =====
    // Path: /deities/{deityId}
    // Full deity information with domains, symbols, relationships

    match /deities/{deityId} {
      // Anyone can read deities
      allow read: if true;

      // Only author can create/update/delete official content
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== HEROES COLLECTION =====
    // Path: /heroes/{heroId}

    match /heroes/{heroId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== CREATURES COLLECTION =====
    // Path: /creatures/{creatureId}

    match /creatures/{creatureId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== COSMOLOGY COLLECTION =====
    // Path: /cosmology/{cosmologyId}

    match /cosmology/{cosmologyId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== HERBS COLLECTION =====
    // Path: /herbs/{herbId}

    match /herbs/{herbId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== RITUALS COLLECTION =====
    // Path: /rituals/{ritualId}

    match /rituals/{ritualId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== TEXTS COLLECTION =====
    // Path: /texts/{textId}

    match /texts/{textId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== ARCHETYPES COLLECTION =====
    // Path: /archetypes/{archetypeId}
    // Cross-mythology archetypes (Sky Father, Trickster, etc.)

    match /archetypes/{archetypeId} {
      // Anyone can read archetypes
      allow read: if true;

      // Only author can create/update/delete
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== MYTHS COLLECTION =====
    // Path: /myths/{mythId}

    match /myths/{mythId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== EVENTS COLLECTION =====
    // Path: /events/{eventId}

    match /events/{eventId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== CONCEPTS COLLECTION =====
    // Path: /concepts/{conceptId}

    match /concepts/{conceptId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== SYMBOLS COLLECTION =====
    // Path: /symbols/{symbolId}

    match /symbols/{symbolId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== PLACES COLLECTION =====
    // Path: /places/{placeId}

    match /places/{placeId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== SEARCH INDEX COLLECTION =====
    // Path: /search_index/{searchId}
    // Searchable entries for full-text search

    match /search_index/{searchId} {
      // Anyone can read search index
      allow read: if true;

      // Only author can create/update/delete
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== CROSS REFERENCES COLLECTION =====
    // Path: /cross_references/{refId}

    match /cross_references/{refId} {
      allow read: if true;
      allow create, update, delete: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }

    // ===== SVG GRAPHICS COLLECTION =====
    // Path: /svg_graphics/{svgId}
    // Store SVG diagrams and visualizations

    match /svg_graphics/{svgId} {
      allow read: if true;

      // Users can create their own SVGs
      allow create: if isAuthenticated()
        && request.resource.data.authorId == request.auth.uid;

      // Users can update their own, author can update any
      allow update: if isAuthenticated()
        && (request.resource.data.authorId == request.auth.uid
            || request.auth.token.email == 'andrewkwatts@gmail.com');

      // Users can delete their own, author can delete any
      allow delete: if isAuthenticated()
        && (resource.data.authorId == request.auth.uid
            || request.auth.token.email == 'andrewkwatts@gmail.com');
    }

    // ===== USER THEORIES COLLECTION =====
    // Path: /user_theories/{theoryId}
    // User-submitted theories (readable/editable by users)

    match /user_theories/{theoryId} {
      function isValidUserTheory() {
        return request.resource.data.keys().hasAll(['title', 'content', 'authorId', 'status'])
               && request.resource.data.title is string
               && request.resource.data.authorId == request.auth.uid;
      }

      // Public read for published theories
      allow read: if resource.data.status == 'published'
                  || isOwner(resource.data.authorId)
                  || request.auth.token.email == 'andrewkwatts@gmail.com';

      // Authenticated users can create theories
      allow create: if isAuthenticated() && isValidUserTheory();

      // Users can update their own theories, author can update any
      allow update: if isAuthenticated()
                    && (isOwner(resource.data.authorId)
                        || request.auth.token.email == 'andrewkwatts@gmail.com')
                    && isValidUserTheory();

      // Users can delete their own, author can delete any
      allow delete: if isAuthenticated()
                    && (isOwner(resource.data.authorId)
                        || request.auth.token.email == 'andrewkwatts@gmail.com');
    }

    // ===== SUBMISSIONS COLLECTION =====
    // Path: /submissions/{submissionId}
    // User submissions for new entities (deities, heroes, creatures, etc.)

    match /submissions/{submissionId} {
      function isValidSubmission() {
        return request.resource.data.keys().hasAll(['id', 'type', 'status', 'data', 'submittedBy', 'entityName'])
               && request.resource.data.id is string
               && request.resource.data.type in ['deity', 'hero', 'creature', 'place', 'item', 'text', 'concept', 'event']
               && request.resource.data.status in ['pending', 'approved', 'rejected']
               && request.resource.data.data is map
               && request.resource.data.submittedBy == request.auth.uid
               && request.resource.data.entityName is string
               && request.resource.data.entityName.size() >= 1
               && request.resource.data.entityName.size() <= 200;
      }

      // Anyone can read approved submissions
      allow get: if resource.data.status == 'approved';
      allow list: if resource.data.status == 'approved'
                  && request.query.limit <= 100;

      // Users can read their own submissions regardless of status
      allow read: if isAuthenticated()
                  && resource.data.submittedBy == request.auth.uid;

      // Admin can read all submissions
      allow read: if isAdminEmail();

      // Authenticated users can create submissions
      allow create: if isAuthenticated()
                    && isValidSubmission()
                    && request.resource.data.status == 'pending'
                    && request.resource.data.submittedBy == request.auth.uid;

      // Users can update their own pending or rejected submissions
      allow update: if isAuthenticated()
                    && resource.data.submittedBy == request.auth.uid
                    && resource.data.status in ['pending', 'rejected']
                    && request.resource.data.submittedBy == request.auth.uid
                    && isValidSubmission();

      // Admin can approve/reject any submission
      allow update: if isAdminEmail()
                    && request.resource.data.submittedBy == resource.data.submittedBy;

      // Users can delete their own pending or rejected submissions
      allow delete: if isAuthenticated()
                    && resource.data.submittedBy == request.auth.uid
                    && resource.data.status in ['pending', 'rejected'];

      // Admin can delete any submission
      allow delete: if isAdminEmail();
    }

    // ===== USER PREFERENCES COLLECTION =====
    // Path: /user_preferences/{userId}
    // User-specific preferences for filtering, display, notifications, etc.

    match /user_preferences/{userId} {
      // Users can only read their own preferences
      allow read: if isAuthenticated() && request.auth.uid == userId;

      // Users can create their own preferences
      allow create: if isAuthenticated()
                    && request.auth.uid == userId
                    && request.resource.data.userId == userId;

      // Users can update their own preferences
      allow update: if isAuthenticated()
                    && request.auth.uid == userId
                    && resource.data.userId == userId
                    && request.resource.data.userId == userId;

      // Users can delete their own preferences
      allow delete: if isAuthenticated() && request.auth.uid == userId;
    }

    // ===== SYSTEM COLLECTION =====
    // Path: /system/{document}
    // Rate limiting, blocked IPs, security logs

    match /system/rate_limits/{identifier} {
      // Only Cloud Functions can read/write rate limits
      allow read, write: if false;
    }

    match /system/blocked_ips/{ipHash} {
      // Only Cloud Functions can read/write blocked IPs
      allow read, write: if false;
    }

    match /system/security_logs/{logId} {
      // Only admin can read security logs
      allow read: if isAdminEmail();
      allow write: if false;
    }

    match /system/abuse_reports/{reportId} {
      // Authenticated users can report abuse
      allow read: if isAdminEmail();
      allow create: if isAuthenticated()
                    && request.resource.data.reporterId == request.auth.uid;
      allow update, delete: if false;
    }

    // ===== MODERATION BANS COLLECTION =====
    // Path: /moderation_bans/{userId}
    // Tracks banned users whose content should be hidden

    match /moderation_bans/{userId} {
      // Only admin can read banned users list
      allow read: if isAdminEmail();

      // Only admin can ban users
      allow create: if isAdminEmail()
                    && request.resource.data.keys().hasAll(['userId', 'bannedBy', 'bannedAt', 'status'])
                    && request.resource.data.userId == userId
                    && request.resource.data.bannedBy == request.auth.uid
                    && request.resource.data.status == 'active';

      // Only admin can update ban status (unban)
      allow update: if isAdminEmail()
                    && request.resource.data.userId == resource.data.userId;

      // Only admin can delete bans
      allow delete: if isAdminEmail();
    }

    // ===== MODERATION FLAGS COLLECTION =====
    // Path: /moderation_flags/{flagId}
    // Tracks flagged content for admin review

    match /moderation_flags/{flagId} {
      // Only admin can read flags
      allow read: if isAdminEmail();

      // Only admin can create flags
      allow create: if isAdminEmail()
                    && request.resource.data.keys().hasAll(['contentType', 'contentId', 'reason', 'flaggedBy', 'flaggedAt', 'status'])
                    && request.resource.data.flaggedBy == request.auth.uid
                    && request.resource.data.status == 'pending';

      // Only admin can update flags (resolve them)
      allow update: if isAdminEmail();

      // Only admin can delete flags
      allow delete: if isAdminEmail();
    }

    // ===== MODERATION HISTORY COLLECTION =====
    // Path: /moderation_history/{historyId}
    // Audit log of all moderation actions

    match /moderation_history/{historyId} {
      // Only admin can read moderation history
      allow read: if isAdminEmail();

      // Only admin can create history entries
      allow create: if isAdminEmail()
                    && request.resource.data.keys().hasAll(['action', 'performedBy', 'timestamp'])
                    && request.resource.data.performedBy == request.auth.uid;

      // History entries should not be updated or deleted (audit trail)
      allow update, delete: if false;
    }

    // ===== USER PERSPECTIVES COLLECTION =====
    // Path: /user_perspectives/{perspectiveId}
    // User-created overlays/interpretations of entities

    match /user_perspectives/{perspectiveId} {
      function isValidPerspective() {
        return request.resource.data.keys().hasAll(['userId', 'entityId', 'entityType', 'entityCollection', 'visibility', 'status'])
               && request.resource.data.userId == request.auth.uid
               && request.resource.data.entityId is string
               && request.resource.data.entityType is string
               && request.resource.data.visibility in ['public', 'private']
               && request.resource.data.status == 'active';
      }

      // Public perspectives visible to all, private only to owner
      allow read: if resource.data.visibility == 'public'
                  || isOwner(resource.data.userId)
                  || isModerator();

      // Authenticated users can create their own perspectives
      allow create: if isAuthenticated()
                    && isValidPerspective()
                    && request.resource.data.upvoteCount == 0
                    && request.resource.data.downvoteCount == 0
                    && request.resource.data.netVotes == 0;

      // Owner can update (cannot change userId, engagement counts)
      allow update: if isOwner(resource.data.userId)
                    && request.resource.data.userId == resource.data.userId
                    && request.resource.data.upvoteCount == resource.data.upvoteCount
                    && request.resource.data.downvoteCount == resource.data.downvoteCount;

      // Owner can delete, moderators can delete flagged content
      allow delete: if isOwner(resource.data.userId) || isModerator();

      // Votes subcollection
      match /votes/{voteUserId} {
        allow read: if true;
        allow write: if isAuthenticated()
                     && request.auth.uid == voteUserId
                     && request.resource.data.value in [1, -1];
      }
    }

    // ===== USER RELATIONSHIPS COLLECTION =====
    // Path: /user_relationships/{relationshipId}
    // User-suggested connections between entities

    match /user_relationships/{relationshipId} {
      function isValidRelationship() {
        return request.resource.data.keys().hasAll(['fromEntityId', 'toEntityId', 'relationshipType', 'suggestedBy', 'title', 'description', 'status'])
               && request.resource.data.suggestedBy == request.auth.uid
               && request.resource.data.title is string
               && request.resource.data.title.size() >= 5
               && request.resource.data.title.size() <= 200
               && request.resource.data.description is string
               && request.resource.data.description.size() >= 20
               && request.resource.data.description.size() <= 2000
               && request.resource.data.relationshipType in ['parallel', 'derived', 'influenced', 'contrasts', 'similar', 'family', 'mythological', 'historical', 'thematic', 'symbolic'];
      }

      // Approved relationships visible to all, pending visible to owner
      allow read: if resource.data.status == 'approved'
                  || isOwner(resource.data.suggestedBy)
                  || isModerator();

      // Authenticated users can suggest relationships
      allow create: if isAuthenticated()
                    && isValidRelationship()
                    && request.resource.data.status == 'pending'
                    && request.resource.data.upvoteCount == 0
                    && request.resource.data.downvoteCount == 0
                    && request.resource.data.isOfficial == false;

      // Owner can update pending/rejected relationships
      allow update: if (isOwner(resource.data.suggestedBy)
                       && resource.data.status in ['pending', 'rejected']
                       && request.resource.data.suggestedBy == resource.data.suggestedBy)
                    || (isAdminEmail() && request.resource.data.suggestedBy == resource.data.suggestedBy);

      // Owner can delete pending, moderators can delete any
      allow delete: if (isOwner(resource.data.suggestedBy) && resource.data.status == 'pending')
                    || isModerator();

      // Votes subcollection
      match /votes/{voteUserId} {
        allow read: if true;
        allow write: if isAuthenticated()
                     && request.auth.uid == voteUserId
                     && request.resource.data.value in [1, -1];
      }

      // Comments subcollection
      match /comments/{commentId} {
        allow read: if true;
        allow create: if isAuthenticated()
                      && request.resource.data.authorId == request.auth.uid
                      && request.resource.data.content is string
                      && request.resource.data.content.size() >= 3
                      && request.resource.data.content.size() <= 2000;
        allow update: if isOwner(resource.data.authorId)
                      && request.resource.data.authorId == resource.data.authorId;
        allow delete: if isOwner(resource.data.authorId) || isModerator();
      }
    }

    // ===== USER REPUTATION COLLECTION =====
    // Path: /user_reputation/{userId}
    // READ-ONLY from client - Cloud Functions calculate reputation

    match /user_reputation/{userId} {
      // Anyone can read reputation (for profiles)
      allow read: if true;

      // ONLY Cloud Functions can write (prevent cheating)
      allow create, update, delete: if false;
    }

    // ===== BADGES COLLECTION =====
    // Path: /badges/{badgeId}
    // Badge definitions (admin-managed)

    match /badges/{badgeId} {
      // Anyone can see badge definitions
      allow read: if true;

      // Only admin can manage badges
      allow create, update, delete: if isAdminEmail();
    }

    // ===== BADGE AWARDS COLLECTION =====
    // Path: /badge_awards/{awardId}
    // READ-ONLY from client - Cloud Functions award badges

    match /badge_awards/{awardId} {
      // Anyone can read badge awards (for profiles)
      allow read: if true;

      // ONLY Cloud Functions can write (prevent cheating)
      allow create, update, delete: if false;
    }

    // ===== COMMUNITY FLAGS COLLECTION =====
    // Path: /community_flags/{flagId}
    // User-initiated content reports

    match /community_flags/{flagId} {
      function isValidFlag() {
        return request.resource.data.keys().hasAll(['contentType', 'contentId', 'flaggedBy', 'reason', 'status'])
               && request.resource.data.flaggedBy == request.auth.uid
               && request.resource.data.reason in ['spam', 'offensive', 'misleading', 'harassment', 'other']
               && request.resource.data.status == 'pending';
      }

      // Only admin can read flags
      allow read: if isAdminEmail();

      // Authenticated users can flag content
      allow create: if isAuthenticated() && isValidFlag();

      // Only admin can update/delete flags
      allow update, delete: if isAdminEmail();
    }

    // ===== DISCUSSIONS COLLECTION =====
    // Path: /discussions/{assetId}/comments/{commentId}
    // Reddit-style threaded discussions for assets
    // Requires corpus search query validation

    match /discussions/{assetId} {
      // Anyone can read discussion metadata
      allow read: if true;

      // Allow creating discussion document (for vote aggregation)
      allow create: if isAuthenticated();
      allow update: if isAuthenticated();

      // Comments subcollection
      match /comments/{commentId} {
        function isValidComment() {
          return request.resource.data.keys().hasAll(['content', 'authorId', 'authorName', 'assetId', 'createdAt'])
                 && request.resource.data.content is string
                 && request.resource.data.content.size() >= 10
                 && request.resource.data.content.size() <= 5000
                 && request.resource.data.authorId == request.auth.uid
                 && request.resource.data.assetId == assetId;
        }

        function hasCorpusQuery() {
          // Corpus query is required for top-level comments (not replies)
          return request.resource.data.parentId != null
                 || (request.resource.data.corpusQuery != null
                     && request.resource.data.corpusQuery.term is string
                     && request.resource.data.corpusQuery.term.size() >= 3);
        }

        // Anyone can read comments
        allow read: if true;

        // Authenticated users can create comments with corpus validation
        allow create: if isAuthenticated()
                      && isValidComment()
                      && hasCorpusQuery()
                      && request.resource.data.netVotes == 0
                      && request.resource.data.upvoteCount == 0
                      && request.resource.data.downvoteCount == 0;

        // Owner can update their own comments (but not vote counts)
        allow update: if isOwner(resource.data.authorId)
                      && request.resource.data.authorId == resource.data.authorId
                      && request.resource.data.netVotes == resource.data.netVotes
                      && request.resource.data.upvoteCount == resource.data.upvoteCount
                      && request.resource.data.downvoteCount == resource.data.downvoteCount;

        // Owner or moderator can delete comments
        allow delete: if isOwner(resource.data.authorId) || isModerator();

        // Votes subcollection for comments
        match /votes/{voteUserId} {
          allow read: if true;
          allow write: if isAuthenticated()
                       && request.auth.uid == voteUserId
                       && request.resource.data.value in [1, -1];
        }
      }

      // Rate limiting for discussions - max 5 comments per minute per user
      match /rate_limits/{userId} {
        allow read: if isAuthenticated() && request.auth.uid == userId;
        allow write: if false; // Only Cloud Functions manage rate limits
      }
    }

    // ===== CORPUS QUERIES COLLECTION =====
    // Path: /corpus_queries/{queryId}
    // Store and track corpus search queries for validation

    match /corpus_queries/{queryId} {
      function isValidQuery() {
        return request.resource.data.keys().hasAll(['label', 'queryType', 'query'])
               && request.resource.data.label is string
               && request.resource.data.queryType in ['github', 'firebase', 'combined'];
      }

      // Anyone can read queries (for reuse)
      allow read: if true;

      // Authenticated users can save queries
      allow create: if isAuthenticated()
                    && isValidQuery()
                    && (request.resource.data.userId == null
                        || request.resource.data.userId == request.auth.uid);

      // Owner can update their own queries, standard queries are admin-only
      allow update: if isAuthenticated()
                    && (resource.data.userId == request.auth.uid
                        || (resource.data.isStandard == true && isAdminEmail()))
                    && request.resource.data.userId == resource.data.userId;

      // Owner can delete their own queries
      allow delete: if isAuthenticated()
                    && resource.data.userId == request.auth.uid
                    && resource.data.isStandard != true;
    }

    // ===== DEFAULT FALLBACK FOR UNDEFINED COLLECTIONS =====
    // Allow read access to any collection not explicitly defined above
    // This is useful for new collections during development
    match /{collection}/{document=**} {
      allow read: if true;
      allow write: if isAuthenticated()
        && request.auth.token.email == 'andrewkwatts@gmail.com';
    }
  }
}
